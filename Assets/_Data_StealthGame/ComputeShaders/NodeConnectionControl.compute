// Control connection and movement of nodes
#pragma kernel UpdateNode

#pragma kernel InitializeConnection

// structure of node
struct Node
{
    int _id; // identify each nodes
    float3 _position; // position of a node
};

// structure of connection between nodes
struct Connection
{
    int _id; // identify each connections
    int _connectNode1; // node to connect
    int _connectNode2; // node to connect
};

// buffer for nodes (for reading)
StructuredBuffer<Node> _nodesBufferRead;

// buffer for nodes (for writing)
RWStructuredBuffer<Node> _nodesBufferWrite;

// buffer for connections (for reading)
StructuredBuffer <Connection> _connectionBufferRead;

// buffer for connections (for writing)
RWStructuredBuffer<Connection> _connectionBufferWrite;

// max number of nodes
uint _nodeCount;

// range of neighbour nodes which affects single node's behaviour
float _neighbourRadious;

// delta time
float _deltaTime;

// max number of connection per one node
uint _maxConnectionPerNode;

// range of searching connectable nodes fron a specific node
float _connectRadious;

// size of thread group
#define SIMULATION_BLOCK_SIZE 256

// shared memory to contain node data
groupshared Node _nodeData[SIMULATION_BLOCK_SIZE];

// height of the floor
float _floorHeight;

// weight of the velocity to avoid floor
float _avoidFloorVelWeight;

// if a node reaches at the floor, return velocity to avoid floor
float3 AvoidFloor(float3 position)
{
    float distanceFromFloorThreshold = 0.05;
    float3 avoidFloorVelocity = float3(0, 1, 0);
    return avoidFloorVelocity * smoothstep(_floorHeight + distanceFromFloorThreshold, _floorHeight, position.y);
}

// return random value
float Random(float3 position)
{
    return frac(sin(dot(position, float3(12.9898, 78.233, 41.028913))));
}

// return value noise
float3 ValueNoise(float3 position)
{
    // get int and fraction of given position
    float3 integer = floor(position);
    float3 fraction = frac(position);

    // sample 8 points
    float a = Random(integer);
    float b = Random(integer + float3(0, 0, 1));
    float c = Random(integer + float3(1, 0, 1));
    float d = Random(integer + float3(1, 0, 0));
    float e = Random(integer + float3(0, 1, 0));
    float f = Random(integer + float3(0, 1, 1));
    float g = Random(integer + float3(1, 1, 0));
    float h = Random(integer + float3(1, 1, 1));

    // smooth interpolation
    // cubic hermine curve
    float3 u = fraction * fraction * (3.0 - 2.0 * fraction);

    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

// return noise
float3 Noise(float3 position) 
{
    return float3(0, 0, 0);
}

// calculate new node position
[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void UpdateNode
(
    uint3 DTid : SV_DispatchThreadID, // global thread index (= Gid.x * SIMULATION_BLOCK_SIZE + GTid.x)
    uint3 Gid : SV_GroupID, // identifier of a group
    uint3 GTid : SV_GroupThreadID, // thread id in a group
    uint GI : SV_GroupIndex // one-dimensional group thread id (0-255)
)
{
    // get position of this node
    float3 thisNodePos = _nodesBufferRead[DTid.x]._position;

    // sum of velocity to separate nodes
    float3 separateVelSum = float3(0, 0, 0);

    // number of neighbour nodes for calculation of saparation velocity
    int separateNodeCount = 0;


    // calculate by each thread groups
    for (uint blockId = 0; blockId < _nodeCount; blockId += SIMULATION_BLOCK_SIZE)
    {
        // contain data of nodes in the shared memory
        _nodeData[GI] = _nodesBufferRead[blockId + GI];

        // wait for group syncing
        GroupMemoryBarrierWithGroupSync();

        // calculate influence of other nodes
        for (uint i = 0; i < SIMULATION_BLOCK_SIZE; i++)
        {
            // another node's position
            float3 otherNodePos = _nodesBufferRead[i]._position;

            // distance between this node and another node
            float dist = distance(thisNodePos, otherNodePos);

            if (dist > 0.0 && dist <= _neighbourRadious)
            {
                // if another node is close, apply force to take distance from another node

                // direction from another node to this node
                float3 otherToThisNodeVector = normalize(thisNodePos - otherNodePos);

                // apply level of influence depending on the distance
                otherToThisNodeVector /= dist;

                // add velocity to separate from another node
                separateVelSum += otherToThisNodeVector;

                // increment neighbour nodes number
                separateNodeCount++;
            }
        }

        // wait for group syncing
        GroupMemoryBarrierWithGroupSync();
    }
    
    // calculate separation velocity
    float3 separateVel = float3(0, 0, 0);
    separateVel = separateNodeCount > 0 ? separateVelSum / (float)separateNodeCount : separateVelSum;

    // calculate avoid floor velocity
    float3 avoidFloor = AvoidFloor(thisNodePos) * _avoidFloorVelWeight;

    // write updated position
    _nodesBufferWrite[DTid.x]._position = thisNodePos + (separateVel + avoidFloor) * _deltaTime;
}

// calculate initial connection between nodes
// max connectable nodes are defined by _maxConnectionPerNode,
// so the space that the single node can take in the connection buffer is also define by _maxConnectionPerNode
[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void InitializeConnection
(
    uint3 DTid : SV_DispatchThreadID // global thread index (= Gid.x * SIMULATION_BLOCK_SIZE + GTid.x)
) 
{
    // get position of this node
    float3 thisNodePos = _nodesBufferRead[DTid.x]._position;
    
    // number of connectable node found in the for loop below; max is _maxConnectionPerNode
    int connectableNodeCount = 0;

    // calculate influence of other nodes
    // max connection per node is limited
    for (uint i = 0; i < _nodeCount; i++)
    {
        // another node's position
        float3 otherNodePos = _nodesBufferRead[i]._position;

        // distance between this node and another node
        float dist = distance(thisNodePos, otherNodePos);

        if (dist > 0.0 && dist <= _connectRadious)
        {
            // if another node is closer than the threshold, connect those nodes

            // if the same combination of nodes is found,
            // this connection isn't stored in the buffer at the final implementation
            // but doubled connection is temprarily accepted while development
            int connectionId = DTid.x * _maxConnectionPerNode + connectableNodeCount;
            _connectionBufferWrite[connectionId]._connectNode1 = _nodesBufferRead[DTid.x]._id;
            _connectionBufferWrite[connectionId]._connectNode2 = _nodesBufferRead[i]._id;
            _connectionBufferWrite[connectionId]._id = connectionId;

            // count connectable node
            connectableNodeCount++;

            // if connectable nodes reached at the max number, end this for loop
            if (connectableNodeCount >= _maxConnectionPerNode) { break; }
        }
    }

    // if the number of connectable nodes is less than _maxConnectionPerNode,
    // copy the data in _connectionBufferRead to _connectionBufferWrite
    // in the rest of buffer for this node
    // original stored values in _connectionBufferRead is;
    // Connection{_id = -1, _connectNode1 = -1, _connectNode2 = -1}
    for (uint i = connectableNodeCount; i < _maxConnectionPerNode; i++) 
    {
        int connectionId = DTid.x * _maxConnectionPerNode + connectableNodeCount;
        _connectionBufferWrite[connectionId]._id = -1;
        _connectionBufferWrite[connectionId]._connectNode1 = _connectionBufferRead[connectionId]._connectNode1;
        _connectionBufferWrite[connectionId]._connectNode2 = _connectionBufferRead[connectionId]._connectNode2;
    }

}